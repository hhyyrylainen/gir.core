using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Generator3.Converter;
using Generator3.Model.V2.Public;
using GirModel;

namespace Generator3.Renderer.V2.Public;

public static class ClassConstructorsRenderer
{
    public static string Render(GirModel.Class cls)
    {
        return $@"
using System;
using System.Linq;
using GObject;
using System.Runtime.InteropServices;
#nullable enable
namespace { cls.Namespace.GetPublicName() }
{{
    // AUTOGENERATED FILE - DO NOT MODIFY

    public partial class { cls.Name }
    {{
        {cls.Constructors
            .Select(x => Render(x, cls))
            .Join(Environment.NewLine)}
    }}
}}";
    }
    
    private static string Render(GirModel.Constructor constructor, GirModel.Class cls)
    {
        try
        {
            var newKeyWord = HidesConstructor(cls, constructor) 
                ? "new " 
                : string.Empty;

            return @$"
public static {newKeyWord}{cls.Name} {constructor.GetPublicName()}({ParametersRenderer.Render(constructor.Parameters)})
{{
    {ParametersToNativeConverter.RenderToNative(constructor.Parameters, out var parameterNames)}
    {RenderCallStatement(cls, constructor, parameterNames)}
}}";
        }
        catch (Exception e)
        {
            var message = $"Did not generate constructor '{cls.Name}.{constructor.GetPublicName()}': {e.Message}";

            if (e is NotImplementedException)
                Log.Debug(message);
            else
                Log.Warning(message);

            return string.Empty;
        }
    }
    
    private static string RenderCallStatement(GirModel.Class cls, GirModel.Constructor constructor, IEnumerable<string> parameterNames)
    {
        var variableName = "handle";
        var call = new StringBuilder();
        call.Append($"var {variableName} = Internal.{cls.Name}.{constructor.GetInternalName()}(");
        call.Append(string.Join(", ", parameterNames));
        call.Append(");" + Environment.NewLine);

        var ownedRef = constructor.ReturnType.Transfer.IsOwnedRef();

        var statement = cls.IsFundamental
            ? $"new {cls.Name}({variableName})"
            : $"new {cls.Name}({variableName}, {ownedRef.ToString().ToLower()})";

        call.Append($"return {statement};");

        return call.ToString();
    }
    
    //TODO: Somehow move this method elsewhere?
    private static bool HidesConstructor(GirModel.Class? cls, GirModel.Constructor constructor)
    {
        if (cls is null)
            return false;

        var publicName = constructor.GetPublicName();
        var matchingConstructor = cls.Constructors.FirstOrDefault(c => c.GetPublicName() == publicName);

        if (matchingConstructor is null)
            return HidesConstructor(cls.Parent, constructor);

        GirModel.Parameter[] parameters = constructor.Parameters.ToArray();
        GirModel.Parameter[] foundParameters = matchingConstructor.Parameters.ToArray();

        if (parameters.Length != foundParameters.Length)
            return HidesConstructor(cls.Parent, constructor);

        for (var i = 0; i < parameters.Length; i++)
        {
            if (!parameters[i].AnyType.Equals(foundParameters[i].AnyType))
                return HidesConstructor(cls.Parent, constructor);
        }

        return true;
    }
}
